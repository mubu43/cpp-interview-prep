# C++ Move Semantics - Complete Study Guide

## Table of Contents
- [Overview](#overview)
- [Core Concepts](#core-concepts)
- [Rvalue References](#rvalue-references)
- [Move Constructor & Assignment](#move-constructor--assignment)
- [Perfect Forwarding](#perfect-forwarding)
- [Return Value Optimization](#return-value-optimization)
- [STL and Move Semantics](#stl-and-move-semantics)
- [Performance Benefits](#performance-benefits)
- [Best Practices](#best-practices)
- [Common Pitfalls](#common-pitfalls)
- [Interview Questions](#interview-questions)
- [Advanced Topics](#advanced-topics)

## Overview

**Move semantics** is one of the most significant features introduced in C++11. It enables efficient transfer of resources from temporary objects, eliminating unnecessary copies and dramatically improving performance for resource-intensive operations.

### The Problem Move Semantics Solves

```cpp
// Pre-C++11: Expensive copying
std::vector<std::string> create_vector() {
    std::vector<std::string> vec;
    // ... populate vector
    return vec;  // Expensive copy on return
}

std::vector<std::string> v1 = create_vector();  // Another copy!
std::vector<std::string> v2 = v1;              // Yet another copy!
```

### The Solution

```cpp
// C++11+: Efficient moving
std::vector<std::string> v1 = create_vector();  // Move (or RVO)
std::vector<std::string> v2 = std::move(v1);    // Move, v1 becomes empty
```

### Key Benefits
- **Performance**: Eliminates expensive copying operations
- **Resource Management**: Clean transfer of ownership
- **Memory Efficiency**: Reduces memory allocations
- **Expressiveness**: Code clearly shows intent to transfer ownership

---

## Core Concepts

### Lvalues vs Rvalues

Understanding value categories is crucial for move semantics:

| Category | Description | Examples | Can Take Address? |
|----------|-------------|----------|-------------------|
| **Lvalue** | Has identity, persists beyond expression | Variables, references | ✅ Yes |
| **Rvalue** | Temporary, doesn't persist | Literals, temporaries, `std::move()` result | ❌ No |

```cpp
int x = 10;        // x is lvalue, 10 is rvalue
int y = x + 5;     // y is lvalue, x+5 is rvalue
int& ref = x;      // ref is lvalue reference
int&& rref = 20;   // rref is rvalue reference

// Important: rvalue references are lvalues when used!
int&& rref2 = std::move(x);  // rref2 is rvalue reference
// rref2 itself is an lvalue when used in expressions
```

### Move vs Copy Semantics

| Operation | Copy Semantics | Move Semantics |
|-----------|----------------|----------------|
| **Resource Handling** | Duplicate resources | Transfer ownership |
| **Source Object** | Unchanged | Valid but unspecified state |
| **Performance** | Expensive for large objects | O(1) for most cases |
| **Safety** | Always safe to use source | Source shouldn't be used |

---

## Rvalue References

Rvalue references (`T&&`) are the foundation of move semantics.

### Declaration and Usage

```cpp
void process(const std::string& s);    // Lvalue reference
void process(std::string&& s);         // Rvalue reference (overload)

std::string str = "hello";
process(str);                          // Calls lvalue version
process(std::move(str));               // Calls rvalue version
process("temporary");                  // Calls rvalue version
```

### Reference Collapsing Rules

When using templates, reference collapsing occurs:

| Template Parameter | Argument Type | Result |
|-------------------|---------------|---------|
| `T&` | `U&` | `U&` |
| `T&` | `U&&` | `U&` |
| `T&&` | `U&` | `U&` |
| `T&&` | `U&&` | `U&&` |

```cpp
template<typename T>
void universal_ref(T&& param);  // Universal/forwarding reference

int x = 10;
universal_ref(x);        // T = int&, param is int&
universal_ref(10);       // T = int, param is int&&
universal_ref(std::move(x)); // T = int, param is int&&
```

---

## Move Constructor & Assignment

### The Rule of Five

If your class manages resources, implement all five:

1. **Destructor**
2. **Copy Constructor**
3. **Copy Assignment Operator**
4. **Move Constructor**
5. **Move Assignment Operator**

### Complete Example

```cpp
class Resource {
private:
    int* data;
    size_t size;

public:
    // Constructor
    Resource(size_t s) : size(s), data(new int[s]) {}
    
    // Destructor
    ~Resource() { delete[] data; }
    
    // Copy constructor
    Resource(const Resource& other) : size(other.size), data(new int[size]) {
        std::copy(other.data, other.data + size, data);
    }
    
    // Copy assignment
    Resource& operator=(const Resource& other) {
        if (this != &other) {
            delete[] data;
            size = other.size;
            data = new int[size];
            std::copy(other.data, other.data + size, data);
        }
        return *this;
    }
    
    // Move constructor
    Resource(Resource&& other) noexcept 
        : data(other.data), size(other.size) {
        other.data = nullptr;  // Leave other in valid state
        other.size = 0;
    }
    
    // Move assignment
    Resource& operator=(Resource&& other) noexcept {
        if (this != &other) {
            delete[] data;          // Clean up current resources
            data = other.data;      // Transfer ownership
            size = other.size;
            other.data = nullptr;   // Reset source
            other.size = 0;
        }
        return *this;
    }
};
```

### Key Points for Move Operations

1. **Mark as `noexcept`**: Enables optimizations in STL containers
2. **Leave source in valid state**: Destructor must be safe to call
3. **Handle self-assignment**: Check `this != &other`
4. **Transfer ownership**: Don't copy, transfer resources

### Generated Move Operations

The compiler generates move operations when:
- ✅ No user-declared copy operations
- ✅ No user-declared move operations  
- ✅ No user-declared destructor

```cpp
class Simple {
    std::string name;
    std::vector<int> data;
    // Compiler generates move operations automatically
};

class Complex {
    std::string name;
    ~Complex() {}  // User-declared destructor
    // No move operations generated - need to implement manually
};
```

---

## Perfect Forwarding

Perfect forwarding preserves the value category of arguments when passing them to other functions.

### The Problem

```cpp
template<typename T>
void wrapper(T param) {  // Always copies!
    target(param);  // param is always an lvalue here
}
```

### The Solution: Universal References + std::forward

```cpp
template<typename T>
void wrapper(T&& param) {  // Universal reference
    target(std::forward<T>(param));  // Preserves value category
}

// Usage
std::string str = "hello";
wrapper(str);              // T = std::string&, forwards as lvalue
wrapper(std::move(str));   // T = std::string, forwards as rvalue
wrapper("literal");        // T = const char(&)[8], forwards as rvalue
```

### Real-World Example: Factory Function

```cpp
template<typename T, typename... Args>
std::unique_ptr<T> make_unique(Args&&... args) {
    return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
}

// Usage preserves argument types
auto ptr1 = make_unique<std::string>(str);           // Copy construct
auto ptr2 = make_unique<std::string>(std::move(str)); // Move construct
auto ptr3 = make_unique<std::string>("literal");      // Construct from literal
```

### When to Use std::forward vs std::move

| Use Case | Function | Purpose |
|----------|----------|---------|
| **Known rvalue** | `std::move()` | Cast to rvalue reference |
| **Universal reference** | `std::forward<T>()` | Preserve value category |
| **Template parameter** | `std::forward<T>()` | Perfect forwarding |

```cpp
template<typename T>
void func(T&& param) {
    // Use std::forward for universal references
    other_func(std::forward<T>(param));
}

void func(MyClass&& obj) {
    // Use std::move for known rvalue references
    other_func(std::move(obj));
}
```

---

## Return Value Optimization

### RVO (Return Value Optimization)

Compilers can eliminate copies when returning objects:

```cpp
MyClass create_object() {
    return MyClass();  // RVO: no copy or move
}

MyClass obj = create_object();  // Direct construction, no copy/move
```

### NRVO (Named Return Value Optimization)

```cpp
MyClass create_object() {
    MyClass obj;
    // ... modify obj
    return obj;  // NRVO: no copy or move (if optimized)
}
```

### When RVO Doesn't Apply

```cpp
MyClass conditional_return(bool flag) {
    if (flag) {
        return MyClass("option1");
    } else {
        return MyClass("option2");
    }
    // Multiple return paths: RVO not guaranteed, move used instead
}

MyClass no_rvo() {
    MyClass obj;
    return std::move(obj);  // DON'T DO THIS: prevents RVO
}
```

### Best Practices for Returns

```cpp
// ✅ Good: Enable RVO
MyClass create() {
    return MyClass();
}

// ✅ Good: Enable NRVO
MyClass create() {
    MyClass obj;
    // modify obj
    return obj;  // Don't use std::move here!
}

// ❌ Bad: Prevents RVO
MyClass create() {
    MyClass obj;
    return std::move(obj);  // Unnecessary
}
```

---

## STL and Move Semantics

### Move-Enabled Operations

Most STL containers and algorithms are move-aware:

```cpp
std::vector<std::string> vec1 = {"hello", "world"};
std::vector<std::string> vec2 = std::move(vec1);  // O(1) move

std::string str = "expensive string";
vec2.push_back(std::move(str));  // Move into container

// Emplace: construct in-place (even better than move)
vec2.emplace_back("constructed", " in place");
```

### emplace vs push/insert

| Operation | Behavior | Performance |
|-----------|----------|-------------|
| `push_back(obj)` | Copy obj into container | Copy construction |
| `push_back(std::move(obj))` | Move obj into container | Move construction |
| `emplace_back(args...)` | Construct object in container | Direct construction |

```cpp
class Point {
public:
    Point(int x, int y) : x_(x), y_(y) {}
    // ... move operations
private:
    int x_, y_;
};

std::vector<Point> points;

// Three ways to add Point(1, 2):
points.push_back(Point(1, 2));           // Construct temporary + move
points.push_back({1, 2});                // Construct temporary + move  
points.emplace_back(1, 2);               // Construct directly in vector
```

### Move Iterators

```cpp
std::vector<std::string> source = {"a", "b", "c"};
std::vector<std::string> dest;

// Move elements instead of copying
std::move(source.begin(), source.end(), std::back_inserter(dest));

// Or use make_move_iterator
std::copy(std::make_move_iterator(source.begin()),
          std::make_move_iterator(source.end()),
          std::back_inserter(dest));
```

### Algorithms with Move Semantics

```cpp
std::vector<std::unique_ptr<int>> ptrs;
ptrs.push_back(std::make_unique<int>(1));
ptrs.push_back(std::make_unique<int>(2));

// Sort using move semantics
std::sort(ptrs.begin(), ptrs.end(),
    [](const auto& a, const auto& b) { return *a < *b; });

// Remove-erase idiom with move
ptrs.erase(std::remove_if(ptrs.begin(), ptrs.end(),
    [](const auto& ptr) { return *ptr > 1; }), ptrs.end());
```

---

## Performance Benefits

### Benchmark Example

```cpp
class ExpensiveResource {
    std::vector<int> data;
public:
    ExpensiveResource(size_t size) : data(size, 42) {}
    // Move operations implemented...
};

// Performance comparison
void copy_test() {
    std::vector<ExpensiveResource> vec;
    ExpensiveResource res(1000000);
    
    auto start = std::chrono::high_resolution_clock::now();
    vec.push_back(res);  // Copy
    auto end = std::chrono::high_resolution_clock::now();
    // Measures copy time
}

void move_test() {
    std::vector<ExpensiveResource> vec;
    ExpensiveResource res(1000000);
    
    auto start = std::chrono::high_resolution_clock::now();
    vec.push_back(std::move(res));  // Move
    auto end = std::chrono::high_resolution_clock::now();
    // Measures move time (much faster!)
}
```

### When Move Semantics Matter Most

1. **Large objects**: `std::vector`, `std::string`, custom containers
2. **Resource-owning objects**: File handles, network connections, smart pointers
3. **Temporary objects**: Function returns, expression results
4. **Container operations**: Insertion, sorting, resizing

### Performance Guidelines

| Scenario | Expected Performance |
|----------|---------------------|
| **Small objects** (int, double) | Move ≈ Copy |
| **Standard containers** | Move >> Copy |
| **Strings** | Move >> Copy (usually) |
| **Smart pointers** | Move >> Copy |
| **User-defined objects** | Depends on implementation |

---

## Best Practices

### 1. Use std::move Correctly

```cpp
// ✅ Good: Transfer ownership
std::string source = "data";
std::string dest = std::move(source);  // source is now empty

// ✅ Good: Pass expensive parameters
void process(std::vector<int> data);   // Pass by value for move
process(std::move(my_vector));         // Caller moves

// ❌ Bad: Moving trivial types
int x = 10;
int y = std::move(x);  // Unnecessary, same as copy

// ❌ Bad: Moving return values
std::string create() {
    std::string local = "data";
    return std::move(local);  // Prevents RVO
}
```

### 2. Implement Move Operations Correctly

```cpp
class Resource {
public:
    // ✅ Good: Proper move constructor
    Resource(Resource&& other) noexcept
        : data_(std::exchange(other.data_, nullptr)) {}
    
    // ✅ Good: Proper move assignment
    Resource& operator=(Resource&& other) noexcept {
        if (this != &other) {
            delete data_;
            data_ = std::exchange(other.data_, nullptr);
        }
        return *this;
    }
    
    // ❌ Bad: Not noexcept (STL won't use move in some cases)
    Resource(Resource&& other) { /* ... */ }
    
    // ❌ Bad: Copying instead of moving
    Resource(Resource&& other) : data_(new int(*other.data_)) {}
};
```

### 3. Use emplace When Possible

```cpp
std::vector<std::pair<std::string, int>> vec;

// ❌ Less efficient
vec.push_back(std::make_pair("key", 42));

// ✅ More efficient
vec.emplace_back("key", 42);

// Container of custom objects
std::vector<Point> points;
points.emplace_back(10, 20);  // Construct Point(10, 20) in-place
```

### 4. Perfect Forwarding in Templates

```cpp
template<typename T, typename... Args>
auto make_object(Args&&... args) {
    return T(std::forward<Args>(args)...);
}

// Preserves value categories
std::string str = "test";
auto obj1 = make_object<MyClass>(str);           // Lvalue forwarded
auto obj2 = make_object<MyClass>(std::move(str)); // Rvalue forwarded
```

### 5. Be Careful with Moved Objects

```cpp
std::string str = "original";
std::string moved = std::move(str);

// ✅ Safe operations on moved objects
str = "new value";    // Assignment
str.clear();          // Member functions that reset state
// Destructor is always safe

// ❌ Unsafe operations
std::cout << str;     // Undefined behavior (implementation-dependent)
str.append("more");   // Undefined behavior
```

---

## Common Pitfalls

### 1. Using Moved Objects

```cpp
// ❌ Dangerous
std::vector<int> vec = {1, 2, 3};
std::vector<int> moved_vec = std::move(vec);
std::cout << vec.size();  // Undefined behavior!

// ✅ Safe
if (!vec.empty()) {  // Check state first
    // Use vec
}
vec = {4, 5, 6};  // Assignment is safe
```

### 2. Unnecessary std::move

```cpp
// ❌ Bad: Prevents RVO
std::string create() {
    std::string result = "data";
    return std::move(result);  // Don't do this!
}

// ✅ Good: Enables RVO
std::string create() {
    std::string result = "data";
    return result;  // RVO optimizes this
}
```

### 3. Moving const Objects

```cpp
const std::string str = "immutable";
std::string moved = std::move(str);  // ❌ Copies instead of moving!

// std::move on const objects binds to copy constructor
```

### 4. Forgetting noexcept

```cpp
class MyClass {
public:
    // ❌ Bad: Missing noexcept
    MyClass(MyClass&& other) { /* ... */ }
    
    // ✅ Good: noexcept enables optimizations
    MyClass(MyClass&& other) noexcept { /* ... */ }
};

// STL containers may use copy instead of move without noexcept
std::vector<MyClass> vec;
vec.resize(100);  // May copy instead of move during reallocation
```

### 5. Double Move

```cpp
void func(std::string&& str) {
    std::string local1 = std::move(str);  // OK: move str
    std::string local2 = std::move(str);  // ❌ Moving from moved object
}
```

---

## Interview Questions

### Q1: What is the difference between std::move and std::forward?

**Answer:**
- `std::move`: Unconditionally casts to rvalue reference, used for known rvalue situations
- `std::forward<T>`: Conditionally casts based on template parameter, preserves value category in perfect forwarding

```cpp
template<typename T>
void wrapper(T&& param) {
    // Use forward for universal references
    target(std::forward<T>(param));
}

void func(MyClass&& obj) {
    // Use move for known rvalue references
    target(std::move(obj));
}
```

### Q2: When should you implement move semantics?

**Answer:**
Implement move semantics when your class:
- Manages expensive-to-copy resources (dynamic memory, file handles, etc.)
- Contains STL containers or other move-enabled objects
- Is used in performance-critical code
- Follows RAII principles

### Q3: What is perfect forwarding and why is it needed?

**Answer:**
Perfect forwarding preserves the value category (lvalue/rvalue) of arguments when passing them through template functions. It's needed because:
- Function parameters are always lvalues, even if they're rvalue references
- We want to preserve whether the original argument was an lvalue or rvalue
- Enables writing generic wrapper functions

### Q4: What happens if you use a moved object?

**Answer:**
After an object is moved from:
- It's in a **valid but unspecified state**
- Safe operations: assignment, destruction, functions that don't depend on current state
- Unsafe operations: accessing members, using object as if it has its original value
- The specific state depends on implementation

### Q5: Why mark move operations as noexcept?

**Answer:**
- **STL optimization**: Containers like `std::vector` use move operations during reallocation only if they're `noexcept`
- **Exception safety**: Move operations shouldn't throw to maintain strong exception safety
- **Performance**: Enables compiler optimizations

### Q6: What is RVO and how does it relate to move semantics?

**Answer:**
RVO (Return Value Optimization) is a compiler optimization that eliminates copies when returning objects:
- **Better than move**: RVO is more efficient than even move semantics
- **Compiler-dependent**: Not guaranteed, but widely implemented
- **Don't use std::move on returns**: This prevents RVO

---

## Advanced Topics

### 1. Move-Only Types

Some types can only be moved, not copied:

```cpp
class MoveOnly {
public:
    MoveOnly() = default;
    MoveOnly(MoveOnly&&) = default;
    MoveOnly& operator=(MoveOnly&&) = default;
    
    // Delete copy operations
    MoveOnly(const MoveOnly&) = delete;
    MoveOnly& operator=(const MoveOnly&) = delete;
};

// Examples: std::unique_ptr, std::thread, std::fstream
```

### 2. Conditional Move

```cpp
template<typename T>
class ConditionalMove {
    T data;
public:
    T get() && {  // Rvalue overload
        return std::move(data);  // Move when called on rvalue
    }
    
    const T& get() const & {  // Lvalue overload
        return data;  // Return reference when called on lvalue
    }
};

ConditionalMove<std::string> obj;
std::string copy = obj.get();                    // Lvalue: returns reference
std::string moved = std::move(obj).get();        // Rvalue: returns moved value
```

### 3. Reference Qualifiers

Member functions can have reference qualifiers:

```cpp
class RefQualified {
    std::vector<int> data;
public:
    // Only callable on lvalues
    void modify() & {
        data.push_back(42);
    }
    
    // Only callable on rvalues
    std::vector<int> extract() && {
        return std::move(data);
    }
};

RefQualified obj;
obj.modify();                    // OK: obj is lvalue
std::move(obj).extract();       // OK: std::move(obj) is rvalue
// std::move(obj).modify();      // Error: can't call & function on rvalue
```

### 4. SFINAE with Move Semantics

```cpp
template<typename T>
class OptionalMove {
    T data;
public:
    // Only provide move constructor if T is movable
    template<typename U = T>
    OptionalMove(OptionalMove&& other,
                std::enable_if_t<std::is_move_constructible_v<U>>* = nullptr)
        : data(std::move(other.data)) {}
    
    // Fallback to copy if move not available
    template<typename U = T>
    OptionalMove(const OptionalMove& other,
                std::enable_if_t<!std::is_move_constructible_v<U>>* = nullptr)
        : data(other.data) {}
};
```

---

## Quick Reference

### Move Operations Checklist

```cpp
class MyClass {
public:
    // Rule of Five
    ~MyClass();                              // Destructor
    MyClass(const MyClass&);                 // Copy constructor
    MyClass& operator=(const MyClass&);      // Copy assignment
    MyClass(MyClass&&) noexcept;            // Move constructor
    MyClass& operator=(MyClass&&) noexcept; // Move assignment
};
```

### When to Use What

| Situation | Use |
|-----------|-----|
| Known rvalue, want to move | `std::move()` |
| Universal reference in template | `std::forward<T>()` |
| Returning local object | Nothing (enable RVO) |
| Passing expensive parameter | Pass by value + move |
| Constructing in container | `emplace` functions |

### Performance Hierarchy

```
Direct construction (emplace)
    ↓ (best)
RVO/NRVO
    ↓
Move semantics
    ↓
Copy semantics
    ↓ (worst)
```

### Common Move-Enabled Types

- `std::string`
- `std::vector`, `std::list`, etc.
- `std::unique_ptr`, `std::shared_ptr`
- `std::function`
- `std::thread`
- `std::fstream`

---

## Summary

Move semantics revolutionizes C++ by:

1. **Eliminating unnecessary copies** through resource transfer
2. **Improving performance** significantly for expensive objects
3. **Enabling perfect forwarding** in generic code
4. **Supporting move-only types** like `std::unique_ptr`
5. **Making code more expressive** about ownership transfer

### Key Takeaways

- **Use move semantics** for expensive-to-copy objects
- **Implement Rule of Five** for resource-managing classes
- **Mark move operations noexcept** for STL compatibility
- **Don't move return values** - prefer RVO
- **Be careful with moved objects** - they're in unspecified state
- **Use perfect forwarding** in generic code
- **Prefer emplace over push** when constructing objects

Move semantics, combined with RAII and smart pointers, enables writing efficient, safe, and expressive modern C++ code!
