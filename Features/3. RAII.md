## RAII (Resource Acquisition Is Initialization)

RAII is a foundational C++ design technique where resource ownership is tied to object lifetime. A resource is acquired during object construction and released during object destruction. This simple rule delivers deterministic cleanup, strong exception safety, and simpler code.

### What counts as a “resource”?
- OS handles: file descriptors, sockets, pipes, shared memory segments
- Memory: heap allocations, buffers
- Synchronization primitives: mutex locks, semaphores
- Graphics and system resources: window handles, device contexts
- Timers, transactions, logging scopes

### The core idea
1. Acquire the resource in the constructor.
2. Release the resource in the destructor.
3. Prevent copying of owning types (to avoid double-free), but allow moving.
4. Let scope boundaries (including exceptions and early returns) drive cleanup.

### Why RAII is useful
- Deterministic destruction: resources are freed exactly when objects go out of scope.
- Exception safety: destructors run during stack unwinding, preventing leaks.
- Simpler control flow: no need for manual `try/finally` or scattered `delete/close` calls.
- Composable code: write small, safe building blocks that manage their own lifetimes.

### A quick mental model
“If an object owns something that must be released, let its destructor do it.”

### Standard Library examples of RAII
- `std::unique_ptr` owns and deletes a heap allocation.
- `std::shared_ptr` manages shared ownership of a heap allocation.
- `std::lock_guard` locks a mutex in its constructor and unlocks it in its destructor.
- `std::fstream` opens a file in its constructor and closes it in its destructor.

### Code example (see `Features/3. RAII.cpp`)
This example demonstrates:
- `FileDescriptor`: a custom RAII wrapper around a POSIX file descriptor (Linux).
- `ScopeTimer`: measures the time a scope takes and reports automatically.
- `std::lock_guard`: RAII for critical sections.
- Behavior on early returns and exceptions—resources are still cleaned up.

### Design guidelines for RAII types
1. Express ownership clearly:
	- If your type owns a resource, make it non-copyable (`delete copy ctor/assign`).
	- Support move semantics to transfer ownership safely.
2. Maintain a clean invariant:
	- “Valid resource” state should be easy to check (e.g., `fd_ >= 0`).
	- If default-constructible, define what “empty” ownership means.
3. Destructors should be `noexcept`:
	- Never throw from destructors. Handle errors via logging or best-effort cleanup.
4. Prefer the Rule of Zero/Rule of Five when applicable:
	- Rule of Zero: rely on standard types that already implement RAII (no custom destructor).
	- Rule of Five: if you manage a raw resource yourself, typically define destructor, copy/move ctor, copy/move assign.
5. Keep acquisition cheap and predictable:
	- Fail fast on constructor errors (throw), leaving no partially-initialized owners.
6. Consider custom deleters:
	- `std::unique_ptr<T, Deleter>` lets you wrap non-`delete` cleanup (e.g., `fclose`, `close`, `munmap`).

### Exception safety and RAII
RAII delivers strong exception safety by ensuring that resources are released during stack unwinding. You don’t need to remember to call cleanup functions; destructors are called automatically.

### Common pitfalls
- Forgetting to disable copying on owning types can lead to double-close/double-free.
- Leaking ownership through raw pointers—prefer smart pointers and references where possible.
- Performing complex logic in destructors—keep cleanup simple and non-throwing.
- Long-lived resources with unclear ownership—define ownership boundaries or use reference-counting.

### When not to use RAII (or use with care)
- Cross-thread ownership handoff without clear lifetime: prefer message passing or shared ownership.
- Async APIs where destruction must be coordinated (e.g., cancel + await): still use RAII, but design explicit stop/shutdown steps that precede destruction.

### Patterns that pair well with RAII
- PImpl (pointer to implementation): hide details while keeping RAII ownership in the implementation.
- Scoped guards (ScopeTimer, logging scopes): start on construction, finalize on destruction.
- Transaction scope objects: commit/rollback on scope exit.

### Interview-ready summary
- RAII ties resource lifetime to object lifetime using constructors/destructors.
- It’s the idiomatic way in C++ to ensure safe cleanup, especially with exceptions.
- Prefer standard RAII types (smart pointers, lock guards, streams) before rolling your own.
- For custom resource wrappers, implement move semantics and delete copy.

### Try it
Build and run the example:

```bash
g++ -std=c++17 -Wall -Wextra -O2 "Features/3. RAII.cpp" -o raii_demo
./raii_demo
```

You should see timing output, safe mutex-protected increments, and files written to `/tmp/raii_demo.txt` and `/tmp/raii_demo_exception.txt` with cleanup happening automatically—even on exceptions and early returns.

