# Smart Pointers in C++ - Study Guide

## Table of Contents
- [Overview](#overview)
- [Types of Smart Pointers](#types-of-smart-pointers)
- [unique_ptr](#unique_ptr)
- [shared_ptr](#shared_ptr)
- [weak_ptr](#weak_ptr)
- [Best Practices](#best-practices)
- [Common Interview Questions](#common-interview-questions)
- [Performance Considerations](#performance-considerations)
- [Common Pitfalls](#common-pitfalls)

## Overview

Smart pointers are objects that act like traditional pointers but provide **automatic memory management**. They are part of the C++11 standard and help prevent:
- Memory leaks
- Dangling pointers
- Double deletion
- Exception safety issues

### Key Benefits
- **RAII (Resource Acquisition Is Initialization)**: Resources are automatically managed
- **Exception Safety**: Memory is cleaned up even when exceptions occur
- **Clear Ownership Semantics**: Code clearly expresses ownership relationships
- **Reduced Bugs**: Eliminates many manual memory management errors

---

## Types of Smart Pointers

| Type | Ownership | Use Case | Header |
|------|-----------|----------|---------|
| `unique_ptr` | Exclusive | Single owner scenarios | `<memory>` |
| `shared_ptr` | Shared | Multiple owners needed | `<memory>` |
| `weak_ptr` | Non-owning | Observer pattern, break cycles | `<memory>` |

---

## unique_ptr

### Characteristics
- **Exclusive ownership**: Only one `unique_ptr` can own a resource
- **Move-only semantics**: Cannot be copied, only moved
- **Zero overhead**: Same performance as raw pointers
- **Automatic cleanup**: Destroys resource when going out of scope

### Creation
```cpp
// Preferred method (C++14+)
auto ptr = std::make_unique<int>(42);

// Alternative (less safe)
std::unique_ptr<int> ptr(new int(42));

// Array version
auto arr = std::make_unique<int[]>(10);
```

### Key Operations
```cpp
// Transfer ownership
std::unique_ptr<int> ptr2 = std::move(ptr1);  // ptr1 becomes null

// Release ownership (returns raw pointer)
int* raw = ptr.release();

// Reset with new resource
ptr.reset(new int(100));

// Get raw pointer (without releasing ownership)
int* raw = ptr.get();

// Check if valid
if (ptr) { /* use ptr */ }
```

### When to Use
- ✅ Default choice for dynamic allocation
- ✅ Factory functions returning objects
- ✅ PIMPL idiom
- ✅ Container elements with unique ownership
- ✅ Exception-safe resource management

### Example Use Cases
```cpp
// Factory function
std::unique_ptr<Database> createDatabase(const std::string& type) {
    if (type == "MySQL") {
        return std::make_unique<MySQLDatabase>();
    }
    return std::make_unique<SQLiteDatabase>();
}

// PIMPL idiom
class Widget {
private:
    class Impl;
    std::unique_ptr<Impl> pImpl;
public:
    Widget();
    ~Widget();  // Required for PIMPL with unique_ptr
};
```

---

## shared_ptr

### Characteristics
- **Shared ownership**: Multiple `shared_ptr` instances can own the same resource
- **Reference counting**: Keeps track of how many owners exist
- **Thread-safe reference counting**: Safe to copy across threads
- **Automatic cleanup**: Destroys resource when last owner is destroyed

### Creation
```cpp
// Preferred method (more efficient)
auto ptr = std::make_shared<int>(42);

// Alternative (less efficient - two allocations)
std::shared_ptr<int> ptr(new int(42));
```

### Key Operations
```cpp
// Copy (increases reference count)
std::shared_ptr<int> ptr2 = ptr1;

// Check reference count
long count = ptr.use_count();

// Reset
ptr.reset();  // Decreases reference count

// Check if unique owner
if (ptr.unique()) { /* only owner */ }

// Get raw pointer
int* raw = ptr.get();
```

### When to Use
- ✅ Multiple objects need to share ownership
- ✅ Object lifetime extends beyond single scope
- ✅ Copying is needed (unlike unique_ptr)
- ✅ Caching scenarios
- ✅ Observer patterns (with weak_ptr)

### Example Use Cases
```cpp
// Shared resource
class ResourceManager {
    std::shared_ptr<ExpensiveResource> resource;
public:
    std::shared_ptr<ExpensiveResource> getResource() {
        if (!resource) {
            resource = std::make_shared<ExpensiveResource>();
        }
        return resource;  // Shared ownership
    }
};

// Multiple containers sharing objects
std::vector<std::shared_ptr<Employee>> allEmployees;
std::vector<std::shared_ptr<Employee>> activeEmployees;
// Same Employee objects can be in both containers
```

---

## weak_ptr

### Characteristics
- **Non-owning observer**: Does not affect object lifetime
- **No reference counting impact**: Doesn't keep object alive
- **Cycle breaking**: Prevents circular references
- **Safe observation**: Can detect if object still exists

### Creation
```cpp
std::shared_ptr<int> shared = std::make_shared<int>(42);
std::weak_ptr<int> weak = shared;  // From shared_ptr
```

### Key Operations
```cpp
// Check if object still exists
if (!weak.expired()) {
    // Object might still exist
}

// Lock to get shared_ptr (safe access)
if (auto shared = weak.lock()) {
    // Use shared safely
    *shared = 100;
}

// Get reference count (of shared_ptrs)
long count = weak.use_count();

// Reset
weak.reset();
```

### When to Use
- ✅ Break circular references
- ✅ Observer pattern implementation
- ✅ Cache implementations
- ✅ Parent-child relationships
- ✅ Callbacks that might outlive the object

### Circular Reference Example
```cpp
// Problem: Circular reference with shared_ptr
class Parent {
    std::shared_ptr<Child> child;
};

class Child {
    std::shared_ptr<Parent> parent;  // Creates cycle!
};

// Solution: Use weak_ptr
class Child {
    std::weak_ptr<Parent> parent;  // Breaks cycle
};
```

---

## Best Practices

### 1. Prefer make_unique and make_shared
```cpp
// ✅ Good - Exception safe, efficient
auto ptr = std::make_shared<Widget>(args);

// ❌ Avoid - Exception unsafe, less efficient
std::shared_ptr<Widget> ptr(new Widget(args));
```

### 2. Use unique_ptr by Default
```cpp
// ✅ Start with unique_ptr
std::unique_ptr<Resource> resource = std::make_unique<Resource>();

// Only use shared_ptr when sharing is actually needed
```

### 3. Pass Smart Pointers Correctly

| Scenario | Parameter Type | Example |
|----------|----------------|---------|
| Use only | `const T&` or `T*` | `void use(const Widget& w)` |
| Might share | `const shared_ptr<T>&` | `void share(const shared_ptr<Widget>& w)` |
| Take ownership | `unique_ptr<T>` | `void take(unique_ptr<Widget> w)` |
| Might take ownership | `shared_ptr<T>` | `void maybeTake(shared_ptr<Widget> w)` |

### 4. Return Smart Pointers from Factories
```cpp
// ✅ Clear ownership transfer
std::unique_ptr<Database> createDatabase();

// ✅ Shared resource
std::shared_ptr<Cache> getCache();
```

### 5. Use weak_ptr for Observers
```cpp
class Subject {
    std::vector<std::weak_ptr<Observer>> observers;
public:
    void notify() {
        for (auto it = observers.begin(); it != observers.end();) {
            if (auto obs = it->lock()) {
                obs->update();
                ++it;
            } else {
                it = observers.erase(it);  // Remove expired observers
            }
        }
    }
};
```

---

## Common Interview Questions

### Q1: What's the difference between unique_ptr and shared_ptr?
**Answer:**
- `unique_ptr`: Exclusive ownership, move-only, zero overhead
- `shared_ptr`: Shared ownership, reference counting, copyable

### Q2: When would you use weak_ptr?
**Answer:**
- Breaking circular references
- Observer patterns
- Caching mechanisms
- When you need to observe an object without keeping it alive

### Q3: Why prefer make_shared over shared_ptr(new T())?
**Answer:**
- **Performance**: Single allocation vs. two allocations
- **Exception safety**: No risk of memory leak if constructor throws
- **Memory locality**: Control block and object allocated together

### Q4: How do you break circular references?
**Answer:**
Use `weak_ptr` for one direction of the relationship:
```cpp
class Parent {
    std::vector<std::shared_ptr<Child>> children;
};

class Child {
    std::weak_ptr<Parent> parent;  // Breaks cycle
};
```

### Q5: What happens when you copy a unique_ptr?
**Answer:**
**Compilation error!** `unique_ptr` is move-only. Use `std::move()` to transfer ownership.

---

## Performance Considerations

### Memory Overhead
| Smart Pointer | Overhead | Notes |
|---------------|----------|-------|
| `unique_ptr` | 0 bytes* | Same as raw pointer |
| `shared_ptr` | 16 bytes | Pointer + control block pointer |
| `weak_ptr` | 16 bytes | Pointer + control block pointer |

*Custom deleters may add overhead

### Performance Tips
1. **Use make_shared**: Single allocation, better cache locality
2. **Prefer unique_ptr**: Zero overhead when possible
3. **Avoid unnecessary copying**: Pass by reference when appropriate
4. **Consider custom deleters**: For special cleanup requirements

### Benchmark Example
```cpp
// Slower - two allocations
auto slow = std::shared_ptr<Widget>(new Widget());

// Faster - single allocation
auto fast = std::make_shared<Widget>();
```

---

## Common Pitfalls

### 1. Double Deletion
```cpp
// ❌ Wrong - creates two control blocks
Widget* raw = new Widget();
std::shared_ptr<Widget> ptr1(raw);
std::shared_ptr<Widget> ptr2(raw);  // Double deletion!

// ✅ Correct
auto ptr = std::make_shared<Widget>();
```

### 2. Circular References
```cpp
// ❌ Memory leak - circular reference
class Node {
    std::shared_ptr<Node> next;
    std::shared_ptr<Node> prev;  // Circular!
};

// ✅ Fixed with weak_ptr
class Node {
    std::shared_ptr<Node> next;
    std::weak_ptr<Node> prev;    // Breaks cycle
};
```

### 3. Mixing Raw and Smart Pointers
```cpp
// ❌ Dangerous
auto smart = std::make_unique<Widget>();
Widget* raw = smart.get();
delete raw;  // Smart pointer will double-delete!

// ✅ Don't mix - use smart pointers consistently
```

### 4. Forgetting to Check weak_ptr
```cpp
// ❌ Dangerous - object might be deleted
std::weak_ptr<Widget> weak = getWeakPtr();
auto shared = weak.lock();
// Don't use shared without checking!

// ✅ Always check
if (auto shared = weak.lock()) {
    // Safe to use shared
}
```

### 5. Performance Misuse
```cpp
// ❌ Unnecessary overhead
void process(std::shared_ptr<Widget> widget);  // Copies shared_ptr

// ✅ Better performance
void process(const Widget& widget);            // No copying
void process(const std::shared_ptr<Widget>& widget);  // Reference
```

---

## Quick Reference Card

### Creation
```cpp
auto unique = std::make_unique<T>(args);
auto shared = std::make_shared<T>(args);
std::weak_ptr<T> weak = shared;
```

### Ownership Transfer
```cpp
auto moved = std::move(unique);  // Transfer ownership
auto copied = shared;            // Share ownership
```

### Access
```cpp
ptr->method();     // Access member
(*ptr).method();   // Dereference and access
T* raw = ptr.get(); // Get raw pointer
```

### Checks
```cpp
if (ptr) { }              // Check if not null
if (ptr.get() != nullptr) // Explicit null check
if (!weak.expired()) { }  // Check if weak_ptr valid
```

### Reset/Release
```cpp
ptr.reset();              // Release current resource
ptr.reset(new T());       // Reset with new resource
T* raw = unique.release(); // Release ownership (unique_ptr only)
```

---

## Summary

Smart pointers are essential for modern C++ development. They provide:
- **Automatic memory management**
- **Clear ownership semantics**
- **Exception safety**
- **Reduced bugs**

**Remember the hierarchy:**
1. **Start with unique_ptr** (exclusive ownership)
2. **Use shared_ptr when sharing is needed** (shared ownership)
3. **Add weak_ptr to break cycles** (non-owning observation)

Master these concepts and you'll write much safer, more maintainable C++ code!
