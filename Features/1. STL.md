# C++ STL (Standard Template Library) - Complete Study Guide

## Table of Contents
- [Overview](#overview)
- [STL Components](#stl-components)
- [Sequence Containers](#sequence-containers)
- [Associative Containers](#associative-containers)
- [Unordered Containers](#unordered-containers)
- [Container Adaptors](#container-adaptors)
- [Iterators](#iterators)
- [Algorithms](#algorithms)
- [Function Objects](#function-objects)
- [STL Utilities](#stl-utilities)
- [Performance Guide](#performance-guide)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)
- [Common Patterns](#common-patterns)

## Overview

The **Standard Template Library (STL)** is the powerhouse of C++ programming, providing a rich collection of generic algorithms, data structures, and utilities. It's designed around the principle of **generic programming** using templates.

### Why STL is Powerful
- **Efficiency**: Highly optimized implementations
- **Reusability**: Generic components work with any data type
- **Consistency**: Uniform interfaces across components
- **Interoperability**: Components work seamlessly together
- **Safety**: Type-safe operations
- **Productivity**: Reduces development time significantly

### Core Philosophy
STL follows these design principles:
1. **Generic Programming**: Templates enable type-independent code
2. **Iterators**: Uniform interface to traverse containers
3. **Separation of Concerns**: Algorithms are separate from containers
4. **Efficiency**: No overhead for unused features

---

## STL Components

### 1. Containers
Data structures that store collections of objects.

### 2. Iterators
Objects that traverse containers, acting as a bridge between containers and algorithms.

### 3. Algorithms
Functions that perform operations on data (sorting, searching, modifying).

### 4. Function Objects (Functors)
Objects that can be called like functions, used to customize algorithm behavior.

### 5. Allocators
Objects that handle memory allocation for containers.

---

## Sequence Containers

Store elements in a **linear sequence** where position matters.

### vector - Dynamic Array

| Feature | Details |
|---------|---------|
| **Access** | Random access O(1) |
| **Insertion** | Back: O(1) amortized, Middle: O(n) |
| **Deletion** | Back: O(1), Middle: O(n) |
| **Memory** | Contiguous storage |
| **Use Case** | Default choice for most scenarios |

```cpp
std::vector<int> vec = {1, 2, 3};
vec.push_back(4);           // Add to end
vec.insert(vec.begin(), 0); // Insert at beginning
vec[2] = 10;                // Random access
vec.reserve(1000);          // Pre-allocate capacity
```

**When to Use:**
- ✅ Need random access
- ✅ Frequent back insertions
- ✅ Cache-friendly operations
- ✅ Interfacing with C APIs

**Avoid When:**
- ❌ Frequent insertions/deletions in middle
- ❌ Frequent front insertions

### deque - Double-Ended Queue

| Feature | Details |
|---------|---------|
| **Access** | Random access O(1) |
| **Insertion** | Front/Back: O(1), Middle: O(n) |
| **Deletion** | Front/Back: O(1), Middle: O(n) |
| **Memory** | Segmented storage |
| **Use Case** | Need efficient front and back operations |

```cpp
std::deque<int> dq;
dq.push_front(1);    // Add to front
dq.push_back(2);     // Add to back
dq[0] = 10;          // Random access
```

**When to Use:**
- ✅ Need efficient front insertions
- ✅ Random access required
- ✅ Queue-like operations

### list - Doubly Linked List

| Feature | Details |
|---------|---------|
| **Access** | Sequential only O(n) |
| **Insertion** | Anywhere: O(1) with iterator |
| **Deletion** | Anywhere: O(1) with iterator |
| **Memory** | Non-contiguous |
| **Use Case** | Frequent insertions/deletions anywhere |

```cpp
std::list<int> lst = {1, 2, 3};
lst.push_front(0);           // Add to front
auto it = lst.begin();
++it;
lst.insert(it, 15);          // Insert before position
lst.remove(2);               // Remove all occurrences of 2
lst.sort();                  // List has its own sort
```

**When to Use:**
- ✅ Frequent insertions/deletions in middle
- ✅ No random access needed
- ✅ Stable iterators required

### forward_list - Singly Linked List

```cpp
std::forward_list<int> flist = {1, 2, 3};
flist.push_front(0);         // Only front operations
flist.insert_after(flist.begin(), 15);
```

**When to Use:**
- ✅ Memory-constrained environments
- ✅ Only forward iteration needed

---

## Associative Containers

Store elements in a **sorted order** based on keys. Implemented as balanced binary trees (usually Red-Black trees).

### set - Unique Sorted Elements

| Feature | Details |
|---------|---------|
| **Access** | Search: O(log n) |
| **Insertion** | O(log n) |
| **Deletion** | O(log n) |
| **Ordering** | Automatically sorted |
| **Duplicates** | Not allowed |

```cpp
std::set<int> s = {3, 1, 4, 1, 5}; // {1, 3, 4, 5}
s.insert(2);                        // {1, 2, 3, 4, 5}
auto it = s.find(3);               // Find element
auto lb = s.lower_bound(3);        // First element >= 3
auto ub = s.upper_bound(3);        // First element > 3
s.erase(4);                        // Remove element
```

**When to Use:**
- ✅ Need sorted unique elements
- ✅ Fast lookups required
- ✅ Range queries needed

### multiset - Sorted Elements (Allows Duplicates)

```cpp
std::multiset<int> ms = {1, 2, 2, 3, 2};
auto count = ms.count(2);          // Count occurrences
auto range = ms.equal_range(2);    // Get range of 2s
```

### map - Key-Value Pairs (Sorted)

| Feature | Details |
|---------|---------|
| **Access** | By key: O(log n) |
| **Insertion** | O(log n) |
| **Deletion** | O(log n) |
| **Ordering** | Sorted by keys |
| **Duplicates** | Unique keys only |

```cpp
std::map<std::string, int> grades = {
    {"Alice", 95}, {"Bob", 87}
};
grades["Charlie"] = 92;            // Insert/update
grades.at("Alice") = 97;           // Safe access
auto it = grades.find("Bob");      // Find by key
grades.erase("Bob");               // Remove by key
```

**When to Use:**
- ✅ Need key-value associations
- ✅ Keys should be sorted
- ✅ Range queries by key

### multimap - Multiple Values per Key

```cpp
std::multimap<std::string, std::string> courses = {
    {"Alice", "Math"}, {"Alice", "Physics"}
};
auto range = courses.equal_range("Alice");
for (auto it = range.first; it != range.second; ++it) {
    std::cout << it->second << " ";
}
```

---

## Unordered Containers

**Hash-based** containers providing average O(1) operations.

### unordered_set - Hash Set

| Feature | Details |
|---------|---------|
| **Access** | Search: O(1) average, O(n) worst |
| **Insertion** | O(1) average, O(n) worst |
| **Deletion** | O(1) average, O(n) worst |
| **Ordering** | No ordering |
| **Duplicates** | Not allowed |

```cpp
std::unordered_set<std::string> words = {"hello", "world"};
words.insert("cpp");
auto it = words.find("hello");
std::cout << "Load factor: " << words.load_factor() << std::endl;
std::cout << "Bucket count: " << words.bucket_count() << std::endl;
```

### unordered_map - Hash Map

```cpp
std::unordered_map<std::string, int> freq;
freq["apple"] = 5;
freq["banana"]++;                  // Creates if doesn't exist
auto it = freq.find("apple");
```

**Hash Containers vs Ordered Containers:**

| Aspect | Ordered (map/set) | Unordered (hash) |
|--------|-------------------|-------------------|
| **Average Access** | O(log n) | O(1) |
| **Worst Case** | O(log n) | O(n) |
| **Ordering** | Yes (sorted) | No |
| **Memory** | Lower overhead | Higher overhead |
| **Cache Performance** | Better for iteration | Worse for iteration |

**When to Use Hash Containers:**
- ✅ Need fastest possible lookups
- ✅ Order doesn't matter
- ✅ Good hash function available

---

## Container Adaptors

Provide **specific interfaces** by adapting existing containers.

### stack - LIFO (Last In, First Out)

```cpp
std::stack<int> stk;
stk.push(10);        // Add to top
stk.push(20);
int top = stk.top(); // Access top element
stk.pop();           // Remove top element
bool empty = stk.empty();
```

**Use Cases:**
- Function call management
- Expression evaluation
- Undo operations
- Backtracking algorithms

### queue - FIFO (First In, First Out)

```cpp
std::queue<int> q;
q.push(10);          // Add to back
q.push(20);
int front = q.front(); // Access front element
q.pop();             // Remove front element
```

**Use Cases:**
- Task scheduling
- BFS algorithms
- Producer-consumer patterns

### priority_queue - Max Heap (by default)

```cpp
std::priority_queue<int> pq;         // Max heap
pq.push(3); pq.push(1); pq.push(4);
int max = pq.top();                  // Gets maximum
pq.pop();                            // Removes maximum

// Min heap
std::priority_queue<int, std::vector<int>, std::greater<int>> minPq;

// Custom comparator
auto cmp = [](int a, int b) { return a > b; };
std::priority_queue<int, std::vector<int>, decltype(cmp)> customPq(cmp);
```

**Use Cases:**
- Dijkstra's algorithm
- A* pathfinding
- Task scheduling with priorities
- Top-K problems

---

## Iterators

**Generalized pointers** that provide uniform access to container elements.

### Iterator Categories

| Category | Operations | Examples |
|----------|------------|----------|
| **Input** | Read once, forward only | `istream_iterator` |
| **Output** | Write once, forward only | `ostream_iterator` |
| **Forward** | Read/write, forward only | `forward_list` |
| **Bidirectional** | Read/write, forward/backward | `list`, `set`, `map` |
| **Random Access** | Read/write, jump anywhere | `vector`, `deque` |

### Common Iterator Operations

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};

// Basic iteration
for (auto it = vec.begin(); it != vec.end(); ++it) {
    std::cout << *it << " ";
}

// Reverse iteration
for (auto it = vec.rbegin(); it != vec.rend(); ++it) {
    std::cout << *it << " ";
}

// Const iteration
for (auto it = vec.cbegin(); it != vec.cend(); ++it) {
    std::cout << *it << " ";  // Cannot modify
}

// Iterator arithmetic (random access only)
auto it = vec.begin();
it += 3;                    // Jump 3 positions
auto distance = vec.end() - vec.begin();
```

### Iterator Utilities

```cpp
// Advance iterator
auto it = vec.begin();
std::advance(it, 3);        // Move 3 positions

// Distance between iterators
auto dist = std::distance(vec.begin(), vec.end());

// Next/Previous
auto next_it = std::next(vec.begin(), 2);
auto prev_it = std::prev(vec.end(), 1);

// Stream iterators
std::copy(vec.begin(), vec.end(), 
          std::ostream_iterator<int>(std::cout, " "));
```

---

## Algorithms

STL provides **80+ algorithms** that work with iterators, making them container-agnostic.

### Algorithm Categories

#### 1. Non-Modifying Algorithms

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5, 4, 3};

// Search
auto it = std::find(vec.begin(), vec.end(), 4);
bool found = std::binary_search(vec.begin(), vec.end(), 3); // Requires sorted

// Count
int count = std::count(vec.begin(), vec.end(), 4);
int count_if = std::count_if(vec.begin(), vec.end(), 
                            [](int x) { return x > 3; });

// Compare
std::vector<int> vec2 = {1, 2, 3, 4, 5, 4, 3};
bool equal = std::equal(vec.begin(), vec.end(), vec2.begin());

// Min/Max
auto min_it = std::min_element(vec.begin(), vec.end());
auto max_it = std::max_element(vec.begin(), vec.end());
auto minmax = std::minmax_element(vec.begin(), vec.end());
```

#### 2. Modifying Algorithms

```cpp
std::vector<int> src = {1, 2, 3, 4, 5};
std::vector<int> dest(5);

// Copy
std::copy(src.begin(), src.end(), dest.begin());
std::copy_if(src.begin(), src.end(), dest.begin(), 
            [](int x) { return x % 2 == 0; });

// Transform
std::transform(src.begin(), src.end(), dest.begin(),
              [](int x) { return x * x; });

// Fill
std::fill(dest.begin(), dest.end(), 42);
std::fill_n(dest.begin(), 3, 99);

// Generate
std::generate(dest.begin(), dest.end(), []() { return rand() % 100; });

// Replace
std::replace(dest.begin(), dest.end(), 42, 0);
std::replace_if(dest.begin(), dest.end(), 
               [](int x) { return x > 50; }, 0);
```

#### 3. Sorting Algorithms

```cpp
std::vector<int> vec = {3, 1, 4, 1, 5, 9, 2, 6};

// Full sort
std::sort(vec.begin(), vec.end());
std::sort(vec.begin(), vec.end(), std::greater<int>()); // Descending

// Partial sort
std::partial_sort(vec.begin(), vec.begin() + 3, vec.end());

// Nth element
std::nth_element(vec.begin(), vec.begin() + 3, vec.end());

// Stable sort (preserves relative order of equal elements)
std::stable_sort(vec.begin(), vec.end());

// Check if sorted
bool is_sorted = std::is_sorted(vec.begin(), vec.end());
```

#### 4. Set Operations (on sorted ranges)

```cpp
std::vector<int> v1 = {1, 2, 3, 4, 5};
std::vector<int> v2 = {3, 4, 5, 6, 7};
std::vector<int> result;

// Union
std::set_union(v1.begin(), v1.end(), v2.begin(), v2.end(),
               std::back_inserter(result));

// Intersection
result.clear();
std::set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(),
                     std::back_inserter(result));

// Difference
result.clear();
std::set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(),
                   std::back_inserter(result));
```

#### 5. Numeric Algorithms

```cpp
std::vector<int> numbers = {1, 2, 3, 4, 5};

// Accumulate
int sum = std::accumulate(numbers.begin(), numbers.end(), 0);
int product = std::accumulate(numbers.begin(), numbers.end(), 1,
                             std::multiplies<int>());

// Partial sum
std::vector<int> partial_sums(numbers.size());
std::partial_sum(numbers.begin(), numbers.end(), partial_sums.begin());

// Adjacent difference
std::vector<int> differences(numbers.size());
std::adjacent_difference(numbers.begin(), numbers.end(), differences.begin());

// Inner product
std::vector<int> v2 = {2, 3, 4, 5, 6};
int dot_product = std::inner_product(numbers.begin(), numbers.end(),
                                    v2.begin(), 0);
```

---

## Function Objects

Objects that can be **called like functions**, used to customize algorithm behavior.

### Predefined Function Objects

```cpp
#include <functional>

std::vector<int> vec = {3, 1, 4, 1, 5};

// Arithmetic
std::transform(vec.begin(), vec.end(), vec.begin(),
              std::bind(std::multiplies<int>(), std::placeholders::_1, 2));

// Comparison
std::sort(vec.begin(), vec.end(), std::greater<int>());

// Logical
auto count = std::count_if(vec.begin(), vec.end(),
                          std::bind(std::logical_and<bool>(),
                                   std::bind(std::greater<int>(), std::placeholders::_1, 2),
                                   std::bind(std::less<int>(), std::placeholders::_1, 5)));
```

### Custom Function Objects

```cpp
struct Multiply {
    int factor;
    Multiply(int f) : factor(f) {}
    int operator()(int x) const { return x * factor; }
};

std::transform(vec.begin(), vec.end(), vec.begin(), Multiply(3));
```

### Lambda Expressions (C++11)

```cpp
// Simple lambda
auto square = [](int x) { return x * x; };

// Lambda with capture
int threshold = 5;
auto count_greater = [threshold](int x) { return x > threshold; };

// Capture by reference
int multiplier = 2;
std::for_each(vec.begin(), vec.end(), 
             [&multiplier](int& x) { x *= multiplier; });

// Generic lambda (C++14)
auto generic = [](auto x, auto y) { return x + y; };

// Complex lambda
auto process = [](const std::vector<int>& v) {
    return std::accumulate(v.begin(), v.end(), 0,
                          [](int sum, int x) { return sum + x * x; });
};
```

---

## STL Utilities

### pair

```cpp
std::pair<std::string, int> person("Alice", 25);
auto coords = std::make_pair(3.14, 2.71);

// Access
std::cout << person.first << " is " << person.second << " years old\n";

// Comparison (lexicographic)
std::pair<int, int> p1(1, 2);
std::pair<int, int> p2(1, 3);
bool less = p1 < p2;  // true
```

### tuple (C++11)

```cpp
std::tuple<std::string, int, double> student("Bob", 20, 3.75);

// Access
std::string name = std::get<0>(student);
int age = std::get<1>(student);
double gpa = std::get<2>(student);

// Structured binding (C++17)
// auto [name, age, gpa] = student;

// Make tuple
auto data = std::make_tuple("Charlie", 22, 3.9);

// Tie (for assignment)
std::string n;
int a;
double g;
std::tie(n, a, g) = student;
```

### Swap and Move

```cpp
// Swap
int a = 10, b = 20;
std::swap(a, b);

std::vector<int> v1 = {1, 2, 3};
std::vector<int> v2 = {4, 5, 6};
std::swap(v1, v2);  // Efficient for containers

// Move semantics
std::vector<int> source = {1, 2, 3, 4, 5};
std::vector<int> dest = std::move(source);  // source is now empty
```

---

## Performance Guide

### Time Complexity Summary

| Container | Access | Insert | Delete | Search |
|-----------|--------|--------|--------|---------|
| **vector** | O(1) | O(1) back, O(n) middle | O(1) back, O(n) middle | O(n) |
| **deque** | O(1) | O(1) ends, O(n) middle | O(1) ends, O(n) middle | O(n) |
| **list** | O(n) | O(1) with iterator | O(1) with iterator | O(n) |
| **set/map** | O(log n) | O(log n) | O(log n) | O(log n) |
| **unordered_set/map** | O(1) avg | O(1) avg | O(1) avg | O(1) avg |

### Memory Considerations

```cpp
// Reserve capacity to avoid reallocations
std::vector<int> vec;
vec.reserve(1000);  // Pre-allocate space

// Shrink to fit
vec.shrink_to_fit();  // Release unused capacity

// Hash container tuning
std::unordered_map<int, int> map;
map.reserve(1000);           // Reserve buckets
map.max_load_factor(0.75);   // Set load factor
```

### Performance Tips

1. **Choose the Right Container**
   - Use `vector` by default
   - Use `unordered_map/set` for fast lookups
   - Use `list` for frequent middle insertions

2. **Iterator Efficiency**
   ```cpp
   // Prefer pre-increment
   for (auto it = container.begin(); it != container.end(); ++it) { }
   
   // Cache end() for better performance
   auto end = container.end();
   for (auto it = container.begin(); it != end; ++it) { }
   ```

3. **Algorithm Selection**
   ```cpp
   // Use algorithms instead of loops
   std::sort(vec.begin(), vec.end());  // Faster than manual sort
   
   // Use appropriate algorithms
   std::binary_search(vec.begin(), vec.end(), value);  // O(log n) on sorted
   std::find(vec.begin(), vec.end(), value);           // O(n) on unsorted
   ```

---

## Best Practices

### 1. Container Selection

```cpp
// ✅ Good: Choose based on usage pattern
std::vector<int> data;          // Default choice
std::unordered_map<string, int> cache;  // Fast lookups
std::set<int> unique_sorted;    // Unique sorted elements

// ❌ Avoid: Wrong container for the job
std::list<int> random_access;   // No random access
std::map<string, int> cache;    // Slower than unordered_map
```

### 2. Algorithm Usage

```cpp
// ✅ Good: Use STL algorithms
std::sort(vec.begin(), vec.end());
auto it = std::find(vec.begin(), vec.end(), value);
std::transform(input.begin(), input.end(), output.begin(), func);

// ❌ Avoid: Manual loops when algorithms exist
for (int i = 0; i < vec.size(); ++i) {
    for (int j = i + 1; j < vec.size(); ++j) {
        if (vec[i] > vec[j]) std::swap(vec[i], vec[j]);
    }
}
```

### 3. Iterator Best Practices

```cpp
// ✅ Good: Use auto and range-based loops
for (const auto& element : container) { }
auto it = std::find(container.begin(), container.end(), value);

// ✅ Good: Check iterator validity
if (it != container.end()) { /* use it */ }

// ❌ Avoid: Manual iterator arithmetic
it = it + 1;  // Use ++it instead
```

### 4. Memory Management

```cpp
// ✅ Good: Reserve space when size is known
std::vector<int> vec;
vec.reserve(expected_size);

// ✅ Good: Use emplace for efficiency
vec.emplace_back(args);  // Construct in place
map.emplace(key, value); // Construct in place

// ❌ Avoid: Unnecessary copies
vec.push_back(ExpensiveObject(args));  // Creates temporary
```

---

## Interview Questions

### Q1: What's the difference between vector and list?
**Answer:**
- `vector`: Dynamic array, O(1) random access, O(1) back insertion, O(n) middle insertion
- `list`: Doubly linked list, O(n) access, O(1) insertion anywhere with iterator

### Q2: When would you use unordered_map vs map?
**Answer:**
- `unordered_map`: O(1) average access, no ordering, use when speed is critical
- `map`: O(log n) access, maintains sorted order, use when ordering matters

### Q3: How do you remove elements while iterating?
**Answer:**
```cpp
// ✅ Correct way
for (auto it = container.begin(); it != container.end();) {
    if (condition(*it)) {
        it = container.erase(it);  // erase returns next iterator
    } else {
        ++it;
    }
}

// Or use remove-erase idiom for vector
vec.erase(std::remove_if(vec.begin(), vec.end(), condition), vec.end());
```

### Q4: What is the remove-erase idiom?
**Answer:**
```cpp
// std::remove doesn't actually remove, it moves elements
auto new_end = std::remove(vec.begin(), vec.end(), value);
vec.erase(new_end, vec.end());  // Actually remove

// Combined:
vec.erase(std::remove(vec.begin(), vec.end(), value), vec.end());
```

### Q5: How do you iterate over a map?
**Answer:**
```cpp
std::map<string, int> m;

// C++11 range-based loop
for (const auto& pair : m) {
    std::cout << pair.first << ": " << pair.second << std::endl;
}

// Structured binding (C++17)
for (const auto& [key, value] : m) {
    std::cout << key << ": " << value << std::endl;
}

// Traditional iterator
for (auto it = m.begin(); it != m.end(); ++it) {
    std::cout << it->first << ": " << it->second << std::endl;
}
```

---

## Common Patterns

### 1. Word Frequency Counter
```cpp
std::unordered_map<std::string, int> frequency;
std::string word;
while (std::cin >> word) {
    frequency[word]++;
}
```

### 2. Top K Elements
```cpp
std::vector<int> findTopK(std::vector<int>& nums, int k) {
    std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;
    
    for (int num : nums) {
        minHeap.push(num);
        if (minHeap.size() > k) {
            minHeap.pop();
        }
    }
    
    std::vector<int> result;
    while (!minHeap.empty()) {
        result.push_back(minHeap.top());
        minHeap.pop();
    }
    return result;
}
```

### 3. LRU Cache
```cpp
class LRUCache {
    int capacity;
    std::list<int> lru;
    std::unordered_map<int, std::pair<int, std::list<int>::iterator>> cache;
    
public:
    LRUCache(int cap) : capacity(cap) {}
    
    int get(int key) {
        auto it = cache.find(key);
        if (it == cache.end()) return -1;
        
        // Move to front
        lru.erase(it->second.second);
        lru.push_front(key);
        it->second.second = lru.begin();
        
        return it->second.first;
    }
    
    void put(int key, int value) {
        auto it = cache.find(key);
        if (it != cache.end()) {
            // Update existing
            lru.erase(it->second.second);
            lru.push_front(key);
            cache[key] = {value, lru.begin()};
        } else {
            // Add new
            if (cache.size() >= capacity) {
                int old = lru.back();
                lru.pop_back();
                cache.erase(old);
            }
            lru.push_front(key);
            cache[key] = {value, lru.begin()};
        }
    }
};
```

### 4. Graph Adjacency List
```cpp
std::unordered_map<int, std::vector<int>> graph;

void addEdge(int u, int v) {
    graph[u].push_back(v);
    graph[v].push_back(u);  // For undirected graph
}

// BFS
void bfs(int start) {
    std::queue<int> q;
    std::unordered_set<int> visited;
    
    q.push(start);
    visited.insert(start);
    
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        
        for (int neighbor : graph[node]) {
            if (visited.find(neighbor) == visited.end()) {
                visited.insert(neighbor);
                q.push(neighbor);
            }
        }
    }
}
```

### 5. Sliding Window Maximum
```cpp
std::vector<int> maxSlidingWindow(std::vector<int>& nums, int k) {
    std::deque<int> dq;  // Store indices
    std::vector<int> result;
    
    for (int i = 0; i < nums.size(); i++) {
        // Remove indices outside window
        while (!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }
        
        // Remove smaller elements
        while (!dq.empty() && nums[dq.back()] <= nums[i]) {
            dq.pop_back();
        }
        
        dq.push_back(i);
        
        if (i >= k - 1) {
            result.push_back(nums[dq.front()]);
        }
    }
    
    return result;
}
```

---

## Quick Reference

### Container Operations
```cpp
// Common operations across containers
container.size()           // Number of elements
container.empty()          // Check if empty
container.clear()          // Remove all elements
container.begin()/end()    // Iterator to begin/end
container.cbegin()/cend()  // Const iterators
container.rbegin()/rend()  // Reverse iterators
```

### Algorithm Shortcuts
```cpp
// Sorting
std::sort(v.begin(), v.end());
std::stable_sort(v.begin(), v.end());
std::partial_sort(v.begin(), v.begin() + k, v.end());

// Searching
std::find(v.begin(), v.end(), value);
std::binary_search(v.begin(), v.end(), value);  // Sorted only
std::lower_bound(v.begin(), v.end(), value);

// Counting
std::count(v.begin(), v.end(), value);
std::count_if(v.begin(), v.end(), predicate);

// Min/Max
std::min_element(v.begin(), v.end());
std::max_element(v.begin(), v.end());
std::minmax_element(v.begin(), v.end());
```

---

## Summary

The C++ STL is incredibly powerful because it provides:

1. **Efficient Data Structures**: Optimized containers for every use case
2. **Generic Algorithms**: Reusable algorithms that work with any container
3. **Iterator Abstraction**: Uniform interface for traversing containers
4. **Composability**: Components work seamlessly together
5. **Performance**: Highly optimized implementations
6. **Safety**: Type-safe operations with clear semantics

**Master these concepts and you'll be able to write efficient, elegant C++ code that leverages decades of optimization and best practices!**

The STL embodies the principle: *"Don't reinvent the wheel, use the best wheel available."*
